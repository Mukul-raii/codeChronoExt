import * as sqlite3 from "sqlite3";
import * as path from "path";
import * as fs from "fs";
import { Logger } from "../utils/logger";

// Structure: "Store-and-Forward" Buffer with Deduplication
// 1. Local DB stores individual activity logs with commit and branch info
// 2. On sync, we aggregate logs by (commitHash, branch, filePath) before sending
// 3. Backend receives compressed file-level summaries per commit
// 4. Backend uses UPSERT with unique constraint to prevent duplicate file activities
//    - Unique constraint: (projectId, commitId, branch, filePath)
//    - If duplicate detected, adds duration to existing entry instead of creating new one
// 5. This ensures efficient storage and prevents 100s+ of duplicate activity logs on server

export interface ActivityLog {
  id?: number; // Optional: Auto-generated by SQLite
  projectPath: string;
  filePath: string;
  language: string;
  timestamp: number;
  duration: number;
  editor?: string;
  commitHash?: string; // Associated git commit
  branch?: string; // Git branch name
}

export interface GitCommit {
  id?: number;
  projectPath: string;
  commitHash: string;
  message: string;
  author: string;
  authorEmail: string;
  timestamp: number;
  filesChanged: number;
  linesAdded: number;
  linesDeleted: number;
  branch?: string;
}

// Aggregated activity data per file per commit
export interface FileActivitySummary {
  projectPath: string;
  commitHash: string;
  branch: string;
  filePath: string;
  language: string;
  totalDuration: number; // Sum of all durations for this file in this commit
  activityCount: number; // Number of individual activities
  firstActivityAt: number; // Timestamp of first activity
  lastActivityAt: number; // Timestamp of last activity
  editor: string;
}

// Aggregated daily activity data
export interface DailyActivitySummary {
  date: string; // YYYY-MM-DD format
  projectPath: string;
  totalDuration: number;
  languageBreakdown: Record<string, number>;
  filesEdited: string[];
  commitCount: number;
}

export class Database {
  private db: sqlite3.Database | null = null;
  private logger = Logger.getInstance();

  constructor(private storagePath: string) {
    // Initialization is now explicit via init()
  }

  public init(): Promise<void> {
    return new Promise((resolve, reject) => {
      if (!fs.existsSync(this.storagePath)) {
        fs.mkdirSync(this.storagePath, { recursive: true });
      }

      const dbPath = path.join(this.storagePath, "codechrono.db");
      this.logger.info(`Initializing database at ${dbPath}`);

      this.db = new sqlite3.Database(dbPath, (err) => {
        if (err) {
          this.logger.error("Failed to connect to database", err);
          reject(err);
        } else {
          this.logger.info("Connected to SQLite database");
          this.createTables().then(resolve).catch(reject);
        }
      });
    });
  }

  private createTables(): Promise<void> {
    return new Promise((resolve, reject) => {
      const activitySql = `
      CREATE TABLE IF NOT EXISTS activity_logs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        project_path TEXT,
        file_path TEXT,
        language TEXT,
        timestamp INTEGER,
        duration INTEGER,
        editor TEXT,
        commit_hash TEXT,
        branch TEXT
      );
    `;

      const commitSql = `
      CREATE TABLE IF NOT EXISTS git_commits (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        project_path TEXT,
        commit_hash TEXT UNIQUE,
        message TEXT,
        author TEXT,
        author_email TEXT,
        timestamp INTEGER,
        files_changed INTEGER,
        lines_added INTEGER,
        lines_deleted INTEGER,
        branch TEXT
      );
    `;

      this.db?.run(activitySql, (err) => {
        if (err) {
          this.logger.error("Error creating activity_logs table", err);
          reject(err);
          return;
        }

        this.db?.run(commitSql, (err) => {
          if (err) {
            this.logger.error("Error creating git_commits table", err);
            reject(err);
            return;
          }

          // Migrate existing tables to add branch column if it doesn't exist
          this.db?.all(
            "PRAGMA table_info(activity_logs)",
            (err, columns: any[]) => {
              if (err) {
                this.logger.error("Error checking activity_logs schema", err);
                reject(err);
                return;
              }

              const hasBranch = columns.some((col) => col.name === "branch");

              if (!hasBranch) {
                this.logger.info(
                  "Migrating activity_logs table to add branch column"
                );
                this.db?.run(
                  "ALTER TABLE activity_logs ADD COLUMN branch TEXT",
                  (err) => {
                    if (err) {
                      this.logger.error(
                        "Error migrating activity_logs table",
                        err
                      );
                      reject(err);
                      return;
                    }
                    this.createIndexes(resolve, reject);
                  }
                );
              } else {
                this.createIndexes(resolve, reject);
              }
            }
          );
        });
      });
    });
  }

  private createIndexes(resolve: () => void, reject: (err: Error) => void) {
    this.logger.info("Creating database indexes");
    // Create indexes for faster sync queries
    this.db?.run(
      "CREATE INDEX IF NOT EXISTS idx_commit_branch ON activity_logs(commit_hash, branch)",
      (err) => {
        if (err) {
          this.logger.error("Error creating activity index", err);
          reject(err);
        } else {
          this.db?.run(
            "CREATE INDEX IF NOT EXISTS idx_timestamp ON activity_logs(timestamp)",
            (err) => {
              if (err) {
                this.logger.error("Error creating timestamp index", err);
                reject(err);
              } else {
                this.logger.info("Database tables and indexes initialized");
                resolve();
              }
            }
          );
        }
      }
    );
  }

  public insertActivity(log: ActivityLog): Promise<void> {
    return new Promise((resolve, reject) => {
      const sql = `INSERT INTO activity_logs (project_path, file_path, language, timestamp, duration, editor, commit_hash, branch) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`;
      this.db?.run(
        sql,
        [
          log.projectPath,
          log.filePath,
          log.language,
          log.timestamp,
          log.duration,
          log.editor || "vscode",
          log.commitHash || null,
          log.branch || null,
        ],
        (err) => {
          if (err) {
            this.logger.error("Error inserting activity log", err);
            reject(err);
          } else {
            resolve();
          }
        }
      );
    });
  }

  public insertCommit(commit: GitCommit): Promise<void> {
    return new Promise((resolve, reject) => {
      const sql = `INSERT OR REPLACE INTO git_commits 
        (project_path, commit_hash, message, author, author_email, timestamp, files_changed, lines_added, lines_deleted, branch) 
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;
      this.db?.run(
        sql,
        [
          commit.projectPath,
          commit.commitHash,
          commit.message,
          commit.author,
          commit.authorEmail,
          commit.timestamp,
          commit.filesChanged,
          commit.linesAdded,
          commit.linesDeleted,
          commit.branch || null,
        ],
        (err) => {
          if (err) {
            this.logger.error("Error inserting git commit", err);
            reject(err);
          } else {
            resolve();
          }
        }
      );
    });
  }

  public getUnsyncedLogs(limit: number = 50): Promise<ActivityLog[]> {
    return new Promise((resolve, reject) => {
      const sql = `SELECT id, project_path as projectPath, file_path as filePath, language, timestamp, duration, editor, commit_hash as commitHash FROM activity_logs ORDER BY timestamp ASC LIMIT ?`;
      this.db?.all(sql, [limit], (err, rows) => {
        if (err) {
          this.logger.error("Error fetching unsynced logs", err);
          reject(err);
        } else {
          resolve(rows as ActivityLog[]);
        }
      });
    });
  }

  public getUnsyncedCommits(limit: number = 20): Promise<GitCommit[]> {
    return new Promise((resolve, reject) => {
      const sql = `SELECT id, project_path as projectPath, commit_hash as commitHash, message, author, author_email as authorEmail, 
        timestamp, files_changed as filesChanged, lines_added as linesAdded, lines_deleted as linesDeleted, branch 
        FROM git_commits ORDER BY timestamp ASC LIMIT ?`;
      this.db?.all(sql, [limit], (err, rows) => {
        if (err) {
          this.logger.error("Error fetching unsynced commits", err);
          reject(err);
        } else {
          resolve(rows as GitCommit[]);
        }
      });
    });
  }

  /**
   * Get aggregated file activity summaries grouped by commit, branch, and file
   * This compresses individual activities into file-level summaries per commit
   */
  public getAggregatedActivities(
    limit: number = 100
  ): Promise<FileActivitySummary[]> {
    return new Promise((resolve, reject) => {
      const sql = `
        SELECT 
          project_path as projectPath,
          commit_hash as commitHash,
          branch,
          file_path as filePath,
          language,
          SUM(duration) as totalDuration,
          COUNT(*) as activityCount,
          MIN(timestamp) as firstActivityAt,
          MAX(timestamp) as lastActivityAt,
          MAX(editor) as editor
        FROM activity_logs
        WHERE commit_hash IS NOT NULL AND branch IS NOT NULL
        GROUP BY project_path, commit_hash, branch, file_path
        ORDER BY firstActivityAt ASC
        LIMIT ?
      `;
      this.db?.all(sql, [limit], (err, rows) => {
        if (err) {
          this.logger.error("Error fetching aggregated activities", err);
          reject(err);
        } else {
          resolve(rows as FileActivitySummary[]);
        }
      });
    });
  }

  /**
   * Delete activity logs that have been aggregated and synced
   * Deletes activities for specific commit/branch/file combinations
   */
  public deleteAggregatedActivities(
    summaries: FileActivitySummary[]
  ): Promise<void> {
    return new Promise((resolve, reject) => {
      if (summaries.length === 0) {
        return resolve();
      }

      // Build DELETE query for all matching activities
      const deletions = summaries.map((summary) => {
        return new Promise<void>((res, rej) => {
          const sql = `DELETE FROM activity_logs WHERE project_path = ? AND commit_hash = ? AND branch = ? AND file_path = ?`;
          this.db?.run(
            sql,
            [
              summary.projectPath,
              summary.commitHash,
              summary.branch,
              summary.filePath,
            ],
            (err) => {
              if (err) {
                this.logger.error("Error deleting aggregated activities", err);
                rej(err);
              } else {
                res();
              }
            }
          );
        });
      });

      Promise.all(deletions)
        .then(() => resolve())
        .catch(reject);
    });
  }

  public deleteLogs(ids: number[]): Promise<void> {
    if (ids.length === 0) {
      return Promise.resolve();
    }
    return new Promise((resolve, reject) => {
      const placeholders = ids.map(() => "?").join(",");
      const sql = `DELETE FROM activity_logs WHERE id IN (${placeholders})`;
      this.db?.run(sql, ids, (err) => {
        if (err) {
          this.logger.error("Error deleting logs", err);
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }

  public deleteCommits(ids: number[]): Promise<void> {
    if (ids.length === 0) {
      return Promise.resolve();
    }
    return new Promise((resolve, reject) => {
      const placeholders = ids.map(() => "?").join(",");
      const sql = `DELETE FROM git_commits WHERE id IN (${placeholders})`;
      this.db?.run(sql, ids, (err) => {
        if (err) {
          this.logger.error("Error deleting commits", err);
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }

  /**
   * Get daily aggregated activities for syncing
   * Groups activities by date and project
   */
  public getDailyAggregatedActivities(
    limit: number = 30
  ): Promise<DailyActivitySummary[]> {
    return new Promise((resolve, reject) => {
      const sql = `
        SELECT 
          DATE(timestamp / 1000, 'unixepoch') as date,
          project_path as projectPath,
          SUM(duration) as totalDuration,
          GROUP_CONCAT(DISTINCT file_path) as files,
          COUNT(DISTINCT commit_hash) as commitCount,
          language,
          SUM(duration) as langDuration
        FROM activity_logs
        WHERE commit_hash IS NOT NULL AND commit_hash != ''
        GROUP BY date, project_path, language
        ORDER BY date DESC
        LIMIT ?
      `;

      this.db?.all(sql, [limit * 10], (err, rows: any[]) => {
        if (err) {
          this.logger.error("Error fetching daily aggregated activities", err);
          reject(err);
          return;
        }

        // Group by date and project
        const summaryMap = new Map<string, DailyActivitySummary>();

        rows.forEach((row) => {
          const key = `${row.date}||${row.projectPath}`;

          if (!summaryMap.has(key)) {
            summaryMap.set(key, {
              date: row.date,
              projectPath: row.projectPath,
              totalDuration: 0,
              languageBreakdown: {},
              filesEdited: [],
              commitCount: row.commitCount || 0,
            });
          }

          const summary = summaryMap.get(key)!;
          summary.totalDuration += row.langDuration;
          summary.languageBreakdown[row.language] =
            (summary.languageBreakdown[row.language] || 0) + row.langDuration;

          if (row.files) {
            const files = row.files.split(",");
            summary.filesEdited = [
              ...new Set([...summary.filesEdited, ...files]),
            ];
          }
        });

        resolve(Array.from(summaryMap.values()).slice(0, limit));
      });
    });
  }

  /**
   * Delete activities that have been aggregated into daily stats
   */
  public deleteActivitiesBeforeDate(beforeDate: string): Promise<void> {
    return new Promise((resolve, reject) => {
      const sql = `
        DELETE FROM activity_logs 
        WHERE DATE(timestamp / 1000, 'unixepoch') < ?
      `;

      this.db?.run(sql, [beforeDate], (err) => {
        if (err) {
          this.logger.error("Error deleting old activities", err);
          reject(err);
        } else {
          this.logger.info(`Deleted activities before ${beforeDate}`);
          resolve();
        }
      });
    });
  }

  public close() {
    this.db?.close((err) => {
      if (err) {
        this.logger.error("Error closing database", err);
      }
    });
  }
}
